# frozen_string_literal: true

module Members
  class AppointmentsController < BaseController
    include AcuityAppointmentSchedulable
    include CareCaseFiltered

    def show
      respond_to do |format|
        format.ics do
          appointment = current_account.appointments.find(params[:id])
          add_to_calendar = Calendaring::AddToCalendar.new(appointment)

          filename = "brightline_#{appointment.appointment_type_id}_#{appointment.start_time.strftime("%Y_%m_%d")}.ics"
          send_data(add_to_calendar.ical_data, filename: filename)
        rescue ActiveRecord::RecordNotFound => _e
          head 404
        end
        format.html do
          @appointment = current_account.appointments.find(params[:id])
          @session_details = current_account_member.teen? ? ::Appointments::TeenSessionDetails.new(@appointment) : ::Appointments::SessionDetails.new(@appointment)
          care_case_context = Family::CareCaseContext.new(care_cases: current_account_member.ordered_care_cases)
          @index = care_case_context.index_for_care_case_id(@appointment.care_case_id)
        end
      end
    end

    def index
      scope = (params[:tab] == "completed") ? "past" : "upcoming"

      @appointments = Appointment.where(care_case: current_accessible_care_cases).public_send(scope).not_canceled.chronological

      Analytics::Event::AppointmentsPage::Viewed.track(account_id: current_account.id)
    end

    def edit
      @appointment = Appointment.where(
        care_case: current_accessible_care_cases + current_pending_care_cases
      ).find(params[:id])

      if @appointment.within_24_hours? && !@appointment.canceled?
        return redirect_to members_appointments_path, flash: {
          notice: "Appointment cannot be rescheduled less than 24 hours before starting."
        }
      end

      @appointment_member = appointment_member
      @availability_data = Calendaring::Appointment::Availability::Data.new(
        date: date,
        slots: available_appointments
      )
    end

    def bookable
      @appointment = Appointment.find(params[:appointment_id])
      @book_appointment_path = book_appointment_path
    rescue Acuity::Api::Client::Error => e
      render_scheduling_error(e, appointment_name: appointment_name)
    end

    private

    def date
      @date ||= if initial_request?
        if Flipper.enabled?(:change_calendaring_times_api)
          first_available_date(
            min_date: min_reschedulable_date,
            appointment_type: @appointment.appointment_type,
            staffers: [@appointment.staffer],
            timezone: appointment_member.timezone,
            care_case: @appointment.care_case
          )
        else
          first_available_date(min_date: min_reschedulable_date)
        end
      else
        Date.parse(params[:date])
      end
    end

    def initial_request?
      !params[:date].present?
    end

    def min_reschedulable_date
      ::Appointments::ReschedulationRules.new(appointment: @appointment).min_reschedulable_date
    end

    def available_appointments
      if Flipper.enabled?(:change_calendaring_times_api)
        availability_request_reporter.track! if initial_request?
        Calendaring::Api::Availability.times(
          root_appointment_type: @appointment.appointment_type.root_appointment_type,
          date_range: date..date,
          timezone: appointment_member.timezone,
          filters: {
            appointment_type: @appointment.appointment_type,
            staffers: [@appointment.staffer],
            region: @appointment.care_case.region
          }
        ).by_legacy_weekly_view
      else
        Calendaring::AvailableAppointments.new(
          date: date,
          availability_context: availability_context,
          availability_request_reporter: legacy_availability_request_reporter
        )
      end
    end

    def availability_request_reporter
      @availability_request_reporter ||= Calendaring::AppointmentAvailabilityRequestReporter.new(
        request_context: Calendaring::AvailabilityRequestContext.appointment_rescheduling,
        care_case: @appointment.care_case,
        member: appointment_member,
        staffers: [@appointment.staffer],
        root_appointment_type: @appointment.appointment_type.root_appointment_type,
        filters: {
          region: @appointment.care_case.region,
          appointment_type: @appointment.appointment_type,
          payer: Eligibility::AssumedResponsiblePayer.for(@appointment.care_case)
        }
      )
    end

    def availability_context
      Calendaring::AvailabilityContext.new(
        appointment_type: @appointment.appointment_type,
        care_case: @appointment.care_case,
        member: appointment_member,
        staffers: [@appointment.staffer],
        request_context: Calendaring::AvailabilityRequestContext.appointment_rescheduling,
        interpretation_language_id: @appointment.interpretation_language_id
      )
    end

    def legacy_availability_request_reporter
      if initial_request?
        Calendaring::AppointmentAvailabilityRequestReporter.from_availability_context(availability_context)
      else
        Calendaring::NoopAvailabilityRequestReporter.new
      end
    end

    def appointment_member
      # this can be refactored once members have been backfilled on appointments
      @appointment_member ||= begin
        appt_member = @appointment.member
        return appt_member if appt_member.present?

        acuity_appointment = Acuity::Api::Appointment.find(@appointment.acuity_appointment_id)
        @appointment.care_case.members.find_by(
          first_name: acuity_appointment.first_name,
          last_name: acuity_appointment.last_name
        )
      end
    end

    def book_appointment_path
      members_care_case_appointment_reschedulations_path(@appointment.care_case, @appointment)
    end

    def appointment_name
      Calendaring::AppointmentNameFromType.find(@appointment.appointment_type_id)
    end
  end
end
