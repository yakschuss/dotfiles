module ApplicationHelper
  include Pagy::Frontend

  def decorative_image_tag(*, **options)
    additional_options = if !options[:alt].present?
      {alt: nil, role: "presentation"}
    else
      options[:alt] = nil
      {role: "presentation"}
    end
    image_tag(*, **options.merge(additional_options))
  end

  def accessible_image_tag(*args, **options)
    additional_options = if !options[:alt].present?
      {alt: ApplicationHelper.alt_text_for_image(args[0])}
    else
      {}
    end
    image_tag(*args, **options.merge(additional_options))
  end

  def accessible_inline_svg_tag(*args, **options)
    additional_options = if !options[:alt].present?
      {alt: ApplicationHelper.alt_text_for_image(args[0])}
    else
      {}
    end
    inline_svg_tag(*args, **options.merge(additional_options))
  end

  def decorative_inline_svg_tag(*, **options)
    additional_options = if !options[:alt].present?
      {alt: nil, role: "presentation"}
    else
      {}
    end
    inline_svg_tag(*, **options.merge(additional_options))
  end

  class << self
    def alt_text_for_contentful_image(url)
      I18n.t(ApplicationHelper.cleanup_filename_for_alt_image(url), scope: :contentful)
    end

    def alt_text_for_image(relative_path)
      split_relative_path = relative_path.split("/")
      filename_without_extension = cleanup_filename_for_alt_image(split_relative_path.last)
      path_excluding_filename = split_relative_path[0...-1].join("/")
      path_parts = ["images", *path_excluding_filename.split("/")] # look in the images scope
      I18n.t(filename_without_extension, scope: path_parts, raise: true)
    end

    def cleanup_filename_for_alt_image(filename)
      filename_without_extension = File.basename(filename, File.extname(filename))
      # Handle . in file names
      filename_without_extension.gsub(".", "___")
    end
  end

  def as_props(hash)
    hash.map { |object| object.respond_to?(:as_json) ? object.as_json : object }
      .to_h
      .deep_transform_keys { |key| key.to_s.camelize(:lower) }
  end

  def friendly_time(time, format: :full_tz, default: nil)
    FriendlyTime.browser_time(time, format: format, default: default)
  end

  def format_duration_in_days_hours(total_hours)
    days = total_hours / 24
    remaining_hours = total_hours % 24
    parts = []
    parts << "#{days} #{'day'.pluralize(days)}" if days > 0
    parts << "#{remaining_hours} #{'hour'.pluralize(remaining_hours)}" if remaining_hours > 0 || parts.empty?
    parts.join(", ")
  end

  def styles
    @styles ||= StyleGuideClasses
  end

  def nav_enabled?
    !@nav_disabled
  end

  def bottom_nav_enabled?
    !@bottom_nav_disabled
  end

  def nav_links
    @nav_links ||= Set.new
  end

  def footer_enabled?
    !@footer_disabled
  end

  def title(text)
    content_for :title, text
  end

  def body_classes(classes)
    content_for(:body_classes, classes)
  end

  def with_favorites(account, member)
    yield Favorite.where(account: account, member: member).all
  end

  # TODO: This does not really need an enum - might want to use a different hash? Or dedicated methods for yes/no?
  def humanized_collection_for_radio_button_from_enum(options)
    Array(options).map do |option|
      OpenStruct.new({text: option.humanize, value: option})
    end
  end
end
