# frozen_string_literal: true

class Staffers::Calendaring::AppointmentCalendarComponent < ApplicationComponent
  # First collect all events without determining overlap
  renders_many :events, ->(time_range:) do
    Event.new(time_range:, rows: rows_for(time_range), start_date: @start_date)
  end

  # Optional header slot for custom headers
  renders_one :header

  HEIGHTS = {
    compact: 3.0,
    expanded: 4.0
  }.freeze

  # TODO: Replace time_range with something like Calendaring::WeeklySchedule::TimeRange or `tod` gem?
  # If we use our TimeRange class, move it somewhere outside of Calendaring::WeeklySchedule.
  # Should Calendaring::WeeklySchedule::RegularHours be shared too?
  #
  # TODO: Should this take date_range instead of start_date + days?
  def initialize(time_range:, time_zone:, start_date:, days: 6, step: 15.minutes, height: :compact)
    @time_range = time_range
    @time_zone = time_zone
    @start_date = start_date
    @days = days
    @step = step
    @base_height = HEIGHTS.fetch(height)
  end

  def time_rows
    (@time_range.begin.to_i...@time_range.end.to_i).step(@step).map do |timestamp|
      time_on_current_day(ActiveSupport::TimeZone[@time_zone].at(timestamp))
    end
  end

  # assume header should be roughly the same height as 1 hour
  def header_row_count
    (1.hour / @step).to_i
  end

  def time_row_count
    time_rows.size
  end

  def rows_for(time_range)
    normalized_start = time_on_current_day(time_range.begin)
    normalized_end = time_on_current_day(time_range.end)
    normalized_range_start = time_on_current_day(@time_range.begin)

    start_row = ((normalized_start - normalized_range_start) / @step + header_row_count + 1).ceil
    end_row = ((normalized_end - normalized_range_start) / @step + header_row_count + 1).ceil

    start_row..end_row
  end

  def grid_styles
    as_style(
      "grid-template-columns" => "3.5rem repeat(#{@days * 2}, minmax(0, 1fr))",
      "grid-template-rows" => "repeat(#{header_row_count + time_row_count}, #{row_height})"
    )
  end

  # TODO: Should we just set the container height and allow rows to fill?
  def row_height
    "#{@base_height / rows_per_hour}rem"
  end

  def rows_per_hour
    1.hour / @step
  end

  def overlap_groups
    return [] if events.empty?

    groups = [[events.first]]
    events[1..].each do |event|
      if event.time_range.begin < groups.last.last.time_range.end
        groups.last << event
      else
        groups << [event]
      end
    end
    groups
  end

  erb_template <<~ERB
    <div class="grid" style="<%= grid_styles %>" data-components--template-calendar-drag-target="grid">
      <%= header || render(DayHeader.new(@start_date, @days, row_span: header_row_count)) %>
      <%= render TimeLabels.new(time_rows, header_row_count, time_zone: @time_zone) %>
      <%= render HourlyGrid.new(@days, time_rows, header_row_count, step: @step) %>
      <% overlap_groups.each do |group| %>
        <% group.each_with_index do |event, index| %>
          <% event.set_overlap_index(index, group.size) %>
          <%= event %>
        <% end %>
      <% end %>
    </div>
  ERB

  class DayHeader < ApplicationComponent
    def initialize(start_date, days, row_span: 1)
      @start_date = start_date
      @days = days
      @row_span = row_span
    end

    erb_template <<~ERB
      <% (@start_date...@start_date + @days).each.with_index do |date, index| %>
        <div class="flex items-center justify-center prism-text-small prism-text-bold" style="grid-row: 1 / <%= @row_span + 1 %>; grid-column: <%= (index + 1) * 2 %> / <%= (index + 2) * 2 %>;">
          <%= Date::DAYNAMES.rotate[index].first(3) %> <%= date.strftime("%-m/%-d") %>
        </div>
      <% end %>
    ERB
  end

  class TimeLabels < ApplicationComponent
    def initialize(time_rows, header_rows, time_zone: nil)
      @time_rows = time_rows
      @header_rows = header_rows
      @time_zone = time_zone
    end

    # TODO: Seems like -top-3 is based on the size of a row
    def classes
      "relative text-right right-4 -top-2 prism-text-mini"
    end

    def styles(index)
      as_style(
        "grid-row" => index + @header_rows + 1,
        "grid-column" => 1
      )
    end

    erb_template <<~ERB
      <% if @time_zone%>
        <div class="relative text-right right-4 prism-text-mini prism-text-bold" 
             style="grid-row: 1 / <%= @header_rows + 1 %>; grid-column: 1; display: flex; align-items: center; justify-content: end;">
          <%= ActiveSupport::TimeZone[@time_zone].now.strftime("%Z") %>
        </div>
      <% end %>
      <% @time_rows.each_with_index do |time, index| %>
        <% next unless time.min.zero? %>
        <%= tag.div class: classes, style: styles(index) do %>
          <%= time.strftime("%-I %p") %>
        <% end %>
      <% end %>
    ERB
  end

  # TODO: Figure this out for a half-hour grid.
  # Also update num_hours to rely on total number of rows instead, and probably some knowledge
  # about hours vs half-hours. So maybe just pass time_rows in here and figure it out?
  class HourlyGrid < ApplicationComponent
    def initialize(num_days, time_rows, header_rows, step: 15.minutes)
      @num_days = num_days
      @time_rows = time_rows
      @header_rows = header_rows
      @step = step
    end

    def styles_for_cell(day_index, time, time_index)
      # Calculate how many grid rows each visual cell should span
      # For 15-minute steps: each 30-minute visual cell spans 2 grid rows
      # For 30-minute steps: each 30-minute visual cell spans 1 grid row
      rows_per_visual_cell = (30.minutes / @step).to_i

      start_row = (time_index * rows_per_visual_cell) + @header_rows + 1
      end_row = ((time_index + 1) * rows_per_visual_cell) + @header_rows + 1

      as_style(
        "grid-row" => "#{start_row} / #{end_row}",
        "grid-column" => "#{day_index * 2} / #{(day_index + 1) * 2}",
        "border-top-style" => time.min.zero? ? "solid" : "dashed",
        # if last row starts on ?:00, bottom border should be a :30 (dashed)
        "border-bottom-style" => time.min.zero? ? "dashed" : "solid"
      )
    end

    def classes_for_cell(day_index, time, time_index)
      tailwind_class_names(
        "border-gray-200 border-l-2 border-t-2 border-b-0 border-r-0 border-solid grid-cell",
        "border-b-2" => time_index == half_hour_or_hour_rows.size - 1,
        "border-r-2" => day_index == @num_days
      )
    end

    def half_hour_or_hour_rows
      @time_rows.select { |time| time.min.in?([0, 30]) }
    end

    def call
      safe_join(
        (1..@num_days).flat_map do |day_index|
          half_hour_or_hour_rows.flat_map.with_index do |time, index|
            tag.div(style: styles_for_cell(day_index, time, index), class: classes_for_cell(day_index, time, index))
          end
        end
      )
    end
  end

  class Event < ApplicationComponent
    attr_reader :time_range

    def initialize(time_range:, rows:, start_date:)
      @time_range = time_range
      # Use relative day from start_date (1-indexed) instead of absolute wday
      @day = (@time_range.begin.to_date - start_date).to_i + 1
      @rows = rows
      @overlap_index = nil
      @has_overlap = false
    end

    def set_overlap_index(index, group_size)
      @overlap_index = index
      @has_overlap = group_size > 1
    end

    def grid_styles
      styles = {
        "grid-row" => "#{@rows.begin} / #{@rows.end}",
        "grid-column" => "#{@day * 2} / span 2",
        "margin" => "2px", # to account for borders
        "position" => "relative" # Ensure z-index works properly
      }

      if @has_overlap
        styles.merge!(
          "width" => "60%",
          "justify-self" => @overlap_index.even? ? "start" : "end",
          "z-index" => @overlap_index.odd? ? "5" : "auto"
        )
      end

      as_style(styles)
    end

    def call
      tag.div(style: grid_styles, data: {calendar_event_wrapper: true}) do
        content
      end
    end
  end

  class LoadingSkeleton < ApplicationComponent
    erb_template <<~ERB
      <div class="grid w-full grid-cols-6 gap-1 h-72 animate-pulse">
        <% 6.times do %>
          <div class="w-full h-full bg-gray-300"></div>
        <% end %>
      </div>
    ERB
  end

  private

  def time_on_current_day(time)
    time.in_time_zone(@time_zone).strftime("%H:%M").in_time_zone(@time_zone)
  end
end
