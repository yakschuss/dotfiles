# frozen_string_literal: true

module Calendaring
  class TemplateBlockTypeService
    class Result
      attr_reader :value, :errors

      def initialize(success:, value: nil, errors: nil)
        @success = success
        @value = value
        @errors = errors || {}
      end

      def success?
        @success
      end

      def failure?
        !@success
      end

      def self.success(value)
        new(success: true, value: value)
      end

      def self.failure(errors)
        new(success: false, errors: errors)
      end
    end

    def self.create(form_params)
      form = Calendaring::TemplateBlockTypeForm.new(form_params)

      unless form.valid?
        return Result.failure(form.errors)
      end

      result = nil

      ActiveRecord::Base.transaction do
        template_block_type = Calendaring::TemplateBlockType.create(
          name: form.name,
          duration_minutes: form.duration_minutes,
          color: form.color
        )

        result = if template_block_type.persisted?
          appointment_result = create_appointment_types(template_block_type, form.appointment_types)
          appointment_result.success? ? Result.success(template_block_type) : appointment_result
        else
          Result.failure(template_block_type.errors)
        end

        raise ActiveRecord::Rollback unless result.success?
      end

      result
    end

    def self.update(template_block_type, form_params)
      form = Calendaring::TemplateBlockTypeForm.new(form_params)

      unless form.valid?
        return Result.failure(form.errors)
      end

      result = nil

      ActiveRecord::Base.transaction do
        update_successful = template_block_type.update(
          name: form.name,
          duration_minutes: form.duration_minutes,
          color: form.color
        )

        result = if update_successful
          # Remove all existing appointment types and recreate them
          template_block_type.template_block_type_appointment_types.destroy_all
          appointment_result = create_appointment_types(template_block_type, form.appointment_types)
          appointment_result.success? ? Result.success(template_block_type) : appointment_result
        else
          Result.failure(template_block_type.errors)
        end

        raise ActiveRecord::Rollback unless result.success?
      end

      result
    end

    BLK_ZERO_DAY_BOOKING_WINDOW_HOURS = 4

    class << self
      private

      def create_appointment_types(template_block_type, appointment_types)
        appointment_types.each do |appointment_type_form|
          next if appointment_type_form.root_appointment_type_id.blank?

          # Convert form mode_selection back to modes array for database storage
          modes = Calendaring::TemplateBlockTypeAppointmentType.selection_to_modes(appointment_type_form.mode_selection)

          appointment_type = Calendaring::TemplateBlockTypeAppointmentType.create(
            template_block_type: template_block_type,
            root_appointment_type_id: appointment_type_form.root_appointment_type_id,
            duration_minutes: appointment_type_form.duration_minutes,
            modes: modes,
            min_booking_window_hours: min_booking_window_hours_for(appointment_type_form),
            max_booking_window_hours: appointment_type_form.max_booking_window_days * 24,
            offsets: appointment_type_form.offsets
          )

          unless appointment_type.persisted?
            return Result.failure(appointment_type.errors)
          end
        end

        Result.success(true)
      end

      def min_booking_window_hours_for(appointment_type_form)
        days = appointment_type_form.min_booking_window_days
        root_appointment_type = RootAppointmentType.find(appointment_type_form.root_appointment_type_id)

        if days.zero? && root_appointment_type.brightlife_kids?
          BLK_ZERO_DAY_BOOKING_WINDOW_HOURS
        else
          days * 24
        end
      end
    end
  end
end
