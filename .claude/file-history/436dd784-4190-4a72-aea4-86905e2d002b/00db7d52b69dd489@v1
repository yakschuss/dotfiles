# frozen_string_literal: true

# == Schema Information
#
# Table name: wait_list_entries
#
#  id                       :uuid             not null, primary key
#  added_at                 :datetime
#  clinic_ids               :uuid             default([]), is an Array
#  notes                    :text
#  priority                 :boolean          default(FALSE), not null
#  removed_at               :datetime
#  removed_by_type          :string
#  removed_reason           :string
#  removed_reason_text      :text
#  created_at               :datetime         not null
#  updated_at               :datetime         not null
#  appointment_type_id      :string
#  care_case_id             :uuid
#  removed_by_id            :uuid
#  root_appointment_type_id :string
#
# Indexes
#
#  index_wait_list_entries_on_care_case_id  (care_case_id)
#  index_wait_list_entries_on_clinic_ids    (clinic_ids)
#
# Foreign Keys
#
#  fk_rails_...  (care_case_id => care_cases.id)
#
class WaitList::Entry < ApplicationRecord
  include YamlModel::Associations

  Status = Enum.new(%w[waiting_for_opening attempting_to_reach removed]) do
    def as_select_options
      [[:all_active, "All active"]] + Status.all.map { |status| [status, status.humanize] }
    end
  end

  RemovedReason = Enum.new(%w[
    scheduled
    clinical_exclusion_criteria_met
    found_another_provider
    preferred_provider_unavailable
    unresponsive
    wait_too_long
    preferred_times_not_available
    coverage_or_cost_concerns
    member_requested_other
  ]) do
    def member_reasons
      %w[found_another_provider wait_too_long preferred_times_not_available coverage_or_cost_concerns member_requested_other]
    end
  end

  belongs_to :care_case
  has_one :account, through: :care_case
  belongs_to_yaml_model :appointment_type, optional: true
  belongs_to_yaml_model :root_appointment_type
  belongs_to :removed_by, polymorphic: true, optional: true
  has_many :outreach_attempts, class_name: "WaitList::OutreachAttempt", dependent: :destroy, foreign_key: :wait_list_entry_id
  has_many :outreach_attempt_events, through: :outreach_attempts, class_name: "WaitList::OutreachAttempt::Event", source: :events

  enum :removed_reason, RemovedReason.as_string_map

  validates :appointment_type_id, inclusion: {in: AppointmentType.ids}, allow_blank: true
  validates :root_appointment_type_id, inclusion: {in: RootAppointmentType.ids}

  scope :active, -> { where(removed_at: nil) }
  scope :inactive, -> { where.not(removed_at: nil) }
  scope :priority, -> { where(priority: true) }
  scope :filter_by, ->(status: nil, region_id: nil, payer_id: nil, appointment_type_id: nil, root_appointment_type_id: nil, clinic_id: nil, priority: nil) do
    scope = self
    scope = scope.with_status(status)
    scope = scope.with_region(region_id)
    scope = scope.with_payer_id(payer_id)
    scope = scope.with_appointment_type_id(appointment_type_id)
    scope = scope.with_root_appointment_type_id(root_appointment_type_id)
    scope = scope.with_clinic_id(clinic_id)
    scope = scope.with_priority(priority)
    scope
  end

  scope :with_status, ->(status) do
    if status.present?
      case status.to_s
      when "all_active"
        where(removed_at: nil)
      when Status.removed
        where.not(removed_at: nil)
      when Status.attempting_to_reach
        where(removed_at: nil, id: WaitList::OutreachAttempt.active.select(:wait_list_entry_id))
      when Status.waiting_for_opening
        where(removed_at: nil).where.not(id: WaitList::OutreachAttempt.active.select(:wait_list_entry_id))
      else
        raise ArgumentError, "Invalid status: #{status}"
      end
    end
  end
  scope :with_region, ->(region_id) { joins(:care_case).where(care_case: {region_id: region_id}) if region_id.present? }
  scope :with_appointment_type_id, ->(appointment_type_id) { where(appointment_type_id: appointment_type_id) if appointment_type_id.present? }
  scope :with_root_appointment_type_id, ->(root_appointment_type_id) { where(root_appointment_type_id: root_appointment_type_id) if root_appointment_type_id.present? }
  scope :with_payer_id, ->(payer_id) {
    return if Array(payer_id).compact_blank.empty?
    where(care_case_id: CareCase.with_payer(payer_id).select(:id))
  }
  scope :with_clinic_id, ->(clinic_id) {
    clinic_ids = Array(clinic_id).compact_blank
    return if clinic_ids.empty?

    where("clinic_ids && ARRAY[?]::uuid[]", clinic_ids)
  }
  scope :with_priority, ->(priority) { where(priority: priority) if priority.present? }
  scope :with_care_case_brightline_id, ->(brightline_id) {
    return if brightline_id.blank?
    joins(:care_case).where("care_cases.brightline_id ILIKE ?", "%#{brightline_id.to_s.strip}%")
  }

  delegate :region, :patient, :caregivers, to: :care_case

  def status
    return Status.removed if removed_at.present?
    return Status.attempting_to_reach if outreach_attempts.active.exists?
    Status.waiting_for_opening
  end

  def humanized_status
    status.humanize
  end

  def humanized_removed_reason
    {
      RemovedReason.member_requested_other => "Other member preference (see notes)"
    }[removed_reason] || removed_reason&.humanize
  end

  def latest_outreach_attempt
    outreach_attempts.order(initiated_at: :desc).first
  end

  def remove!(removed_reason:, removed_by:, removed_reason_text: nil)
    transaction do
      update!(removed_at: Time.current, removed_reason:, removed_by:, removed_reason_text:)
      CareCaseTagging::Assignment.new(care_case:).remove_tag(CareCaseTagging::Tag.waitlisted.to_sym)
    end
    true
  rescue ActiveRecord::RecordInvalid
    false
  end

  def active?
    !removed?
  end

  def removed?
    removed_at.present?
  end

  def clinics
    Clinic.where(id: clinic_ids)
  end
end
