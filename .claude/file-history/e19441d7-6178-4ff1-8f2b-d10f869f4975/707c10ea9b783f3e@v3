# frozen_string_literal: true

require "rails_helper"

RSpec.describe RootAppointmentType do
  describe "#variable_duration?" do
    context "when root appointment type has multiple active appointment types with different durations for same mode/assistance" do
      it "returns true" do
        # psychological_testing_continued has 1, 2, 3, 4 hour variants for in_person
        root_type = described_class.find(:psychological_testing_continued)

        expect(root_type.variable_duration?).to be true
      end
    end

    context "when root appointment type has only one duration per mode/assistance combination" do
      it "returns false" do
        # coaching_goal_setting has only one duration per mode
        root_type = described_class.find(:coaching_goal_setting)

        expect(root_type.variable_duration?).to be false
      end
    end

    context "when root appointment type has no active appointment types" do
      it "returns false without raising an error" do
        # first_phone_call is a real production case where all appointment_types are inactive
        # This was causing the NoMethodError: undefined method '>' for nil
        root_type = described_class.find(:first_phone_call)

        # Should not raise NoMethodError on nil
        expect { root_type.variable_duration? }.not_to raise_error
        expect(root_type.variable_duration?).to be false
      end
    end
  end

  describe "#appointment_types" do
    it "only returns active appointment types" do
      root_type = described_class.find(:therapy_session)

      appointment_types = root_type.appointment_types

      expect(appointment_types).to all(be_active)
    end
  end

  describe "#required_capability_id" do
    context "ongoing coaching appointment types" do
      it "requires coaching_ongoing capability for coaching_session" do
        expect(described_class.find(:coaching_session).required_capability_id).to eq("coaching_ongoing")
      end

      it "requires coaching_ongoing capability for coaching_caregiver_session" do
        expect(described_class.find(:coaching_caregiver_session).required_capability_id).to eq("coaching_ongoing")
      end

      it "requires coaching_ongoing capability for coaching_booster_session" do
        expect(described_class.find(:coaching_booster_session).required_capability_id).to eq("coaching_ongoing")
      end

      it "requires coaching_ongoing capability for coaching_brief_check_in" do
        expect(described_class.find(:coaching_brief_check_in).required_capability_id).to eq("coaching_ongoing")
      end
    end

    context "intake coaching appointment types" do
      it "requires coaching_intake capability for coaching_goal_setting" do
        expect(described_class.find(:coaching_goal_setting).required_capability_id).to eq("coaching_intake")
      end
    end
  end

  describe "#for_templates?" do
    it "returns true for clinic care model appointment types" do
      root_type = described_class.find(:therapy_session)

      expect(root_type.for_templates?).to be true
    end

    it "returns true for brightlife_kids care model when feature flag is enabled" do
      Flipper.enable(:blk_catchup_coaching_enablement)
      root_type = described_class.find(:coaching_session)

      expect(root_type.for_templates?).to be true
    ensure
      Flipper.disable(:blk_catchup_coaching_enablement)
    end

    it "returns false for brightlife_kids care model when feature flag is disabled" do
      Flipper.disable(:blk_catchup_coaching_enablement)
      root_type = described_class.find(:coaching_session)

      expect(root_type.for_templates?).to be false
    end
  end
end
