# frozen_string_literal: true

# == Schema Information
#
# Table name: sendbird_chat_channels
#
#  id             :uuid             not null, primary key
#  chat_type      :string
#  deactivated_at :datetime
#  frozen_at      :datetime
#  last_synced_at :datetime
#  url            :string
#  created_at     :datetime         not null
#  updated_at     :datetime         not null
#  account_id     :uuid             not null
#  care_case_id   :uuid
#  chat_id        :string
#
# Indexes
#
#  index_sendbird_chat_channels_on_account_id_and_chat_type  (account_id,chat_type)
#  index_sendbird_chat_channels_on_care_case_id              (care_case_id)
#  index_sendbird_chat_channels_on_chat_id                   (chat_id) UNIQUE
#  index_sendbird_chat_channels_on_chat_type                 (chat_type)
#  index_sendbird_chat_channels_on_url                       (url)
#
# Foreign Keys
#
#  fk_rails_...  (account_id => accounts.id)
#
class SendbirdChatChannel < ApplicationRecord
  belongs_to :account
  belongs_to :care_case, optional: true

  has_many :memberships, class_name: "SendbirdChatChannelMembership", dependent: :destroy
  has_many :sendbird_users, through: :memberships
  # This association is used to pre-load certain sendbird users in Chat::AccessibleStafferChannel
  has_many :_accessible_sendbird_users, through: :memberships, source: :sendbird_user
  has_many :flags, class_name: "Chat::Flag", foreign_key: :sendbird_chat_channel_id, primary_key: :id, dependent: :destroy
  has_many :admin_messages, class_name: "Chat::AdminMessage", dependent: :destroy

  has_many :automated_chat_messages, dependent: :destroy

  enum :chat_type, Chat::Type.as_string_map, prefix: :chat_type
  validates :chat_id, :chat_type, presence: true

  scope :active, -> { where(deactivated_at: nil) }
  scope :for_account, ->(account_id) { where(account_id: account_id) }
  scope :unread_and_ordered_by_recency, ->(sendbird_user, sort_order = :desc) {
    with_unread_messages_for(sendbird_user).order("sendbird_chat_channel_memberships.last_message_sent_at": sort_order)
  }
  scope :with_unread_messages_for, ->(sendbird_user) {
    for_sendbird_user(sendbird_user).merge(SendbirdChatChannelMembership.with_unread_messages)
  }
  scope :with_message_sent_by_member_since, ->(sent_cutoff_date) {
    joins(memberships: :sendbird_user).where(sendbird_chat_channel_memberships: {sendbird_users: {role: Chat::Role.member}, last_message_sent_at: (sent_cutoff_date..)})
  }
  scope :for_sendbird_user, ->(sendbird_user) { joins(:memberships).where(sendbird_chat_channel_memberships: {sendbird_user_id: sendbird_user}) }
  scope :for_member, ->(member) { active.for_sendbird_user(member.sendbird_user) }
  scope :for_care_case, ->(care_case:, member:) { active.for_account(care_case.account).where(care_case: care_case).for_sendbird_user(member.sendbird_user) }
  scope :for, ->(account:, member:) { active.for_account(account).for_sendbird_user(member.sendbird_user) }
  scope :needing_sync, -> { active.where("updated_at > COALESCE(last_synced_at, ?)", 2.weeks.ago) }

  def self.coach_channel_for(account:, member:)
    self.for(account: account, member: member).chat_type_coach.first
  end

  def self.member_support_channel_for(account:, member:)
    self.for(account: account, member: member).chat_type_member_support.first
  end

  def self.care_guide_channel_for(account:, member:)
    self.for(account: account, member: member).chat_type_care_guide.first
  end

  def self.therapist_channels_for_care_case(care_case:, member:)
    for_care_case(care_case:, member:).chat_type_therapist
  end

  def self.prescriber_channels_for_care_case(care_case:, member:)
    for_care_case(care_case:, member:).chat_type_prescriber
  end

  def active?
    !deactivated?
  end

  def deactivated?
    deactivated_at.present?
  end

  def deactivate!
    self.deactivated_at ||= Time.zone.now
    save!
  end

  def last_message_content
    membership_with_last_sent_message&.last_message_content
  end

  def last_message_sent_at
    membership_with_last_sent_message&.last_message_sent_at
  end

  def membership_with_last_sent_message
    return if memberships.empty?

    memberships.where.not(last_message_sent_at: nil).order(last_message_sent_at: :desc).first
  end

  def nickname_with_last_sent_message
    membership_with_last_sent_message&.sendbird_user&.nickname
  end

  def staffers
    sendbird_users.where(role: Chat::Role.staffer).map(&:participant)
  end

  def staffer
    staffers.first
  end

  # TODO: Move to Conversation model
  def overdue?(sendbird_user)
    sendbird_user_membership = memberships.find_by(sendbird_user: sendbird_user)
    return false unless last_message_sent_at.present? && sendbird_user_membership.present?

    membership_with_last_sent_message != sendbird_user_membership && last_message_sent_at.before?(4.business_hours.ago)
  end

  def member_messaged?(member:, validate_chat_type: nil)
    return false if validate_chat_type && chat_type != validate_chat_type

    Sendbird::Api::GroupChannel.messages(channel_url: url).any? do |message|
      message.type == "MESG" && message.user.user_id == member.sendbird_user.external_id
    end
  end

  def last_admin_message_for(message_type)
    admin_messages
      .where(message_type: message_type)
      .order(sent_at: :desc)
      .first
  end
end
