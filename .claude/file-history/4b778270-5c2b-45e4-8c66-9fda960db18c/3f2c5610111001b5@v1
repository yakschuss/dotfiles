# frozen_string_literal: true

class Api::Mobile::Accounts::CareCases::Appointments::ReschedulationsController < Api::Mobile::ApiController
  include Api::Mobile::Authentication
  include Api::Mobile::AccountValidation
  include Api::Mobile::CareCaseValidation

  before_action :validate_auth_token!
  before_action :validate_account!
  before_action :validate_care_case!
  before_action :validate_appointment!

  rescue_from(Acuity::Api::Client::ApiError) do
    handle_api_error(Api::Mobile::Errors::SystemFailureError.new)
  end

  def create
    Calendaring::MemberReschedulation.save!(
      appointment: current_appointment,
      start_time: new_start_time
    )
    head :no_content
  end

  def availabilities
    @appointment_slots = if Flipper.enabled?(:change_calendaring_times_api)
      availability_request_reporter.track! if initial_request?
      Calendaring::Api::Availability.times(
        root_appointment_type: current_appointment.appointment_type.root_appointment_type,
        date_range: availability_date..availability_date,
        timezone: current_member.timezone,
        filters: {
          appointment_type: current_appointment.appointment_type,
          staffers: [current_appointment.staffer],
          region: current_appointment.care_case.region
        }
      ).by_legacy_weekly_view
    else
      Calendaring::AvailableAppointments.new(
        date: availability_date,
        availability_context: availability_context,
        availability_request_reporter: legacy_availability_request_reporter
      ).slots
    end
    @group_id = availability_group_id || generate_availability_group_id
  end

  private

  def validate_appointment!
    raise Api::Mobile::Errors::MissingAppointmentIdError unless appointment_id.present?
    raise Api::Mobile::Errors::AppointmentNotFoundError unless current_appointment.present?

    if current_appointment.within_24_hours?
      return if current_appointment.canceled?
      raise Api::Mobile::Errors::AppointmentChangeNotAllowedError
    end
  end

  def current_appointment
    @current_appointment ||= current_care_case.appointments.find_by(id: appointment_id)
  end

  def appointment_id
    params["appointment_id"]
  end

  def new_start_time
    @start_time ||= DateTime
      .parse(params.require(:start_time))
      .in_time_zone(current_member.timezone)
  end

  def availability_date
    (params[:date] || current_appointment.start_time).to_date
  end

  def availability_request_reporter
    @availability_request_reporter ||= Calendaring::AppointmentAvailabilityRequestReporter.new(
      request_context: Calendaring::AvailabilityRequestContext.appointment_rescheduling,
      care_case: current_appointment.care_case,
      member: current_member,
      staffers: [current_appointment.staffer],
      root_appointment_type: current_appointment.appointment_type.root_appointment_type,
      filters: {
        region: current_appointment.care_case.region,
        appointment_type: current_appointment.appointment_type,
        payer: Eligibility::AssumedResponsiblePayer.for(current_appointment.care_case)
      }
    )
  end

  def availability_context
    Calendaring::AvailabilityContext.new(
      appointment_type: current_appointment.appointment_type,
      care_case: current_appointment.care_case,
      member: current_member,
      staffers: [current_appointment.staffer],
      request_context: Calendaring::AvailabilityRequestContext.appointment_rescheduling,
      interpretation_language_id: current_appointment.interpretation_language_id
    )
  end

  def legacy_availability_request_reporter
    if initial_request?
      Calendaring::AppointmentAvailabilityRequestReporter.from_availability_context(availability_context)
    else
      Calendaring::NoopAvailabilityRequestReporter.new
    end
  end

  def initial_request?
    availability_group_id.present?
  end

  def availability_group_id
    params[:group_id]
  end

  def generate_availability_group_id
    SecureRandom.alphanumeric
  end
end
