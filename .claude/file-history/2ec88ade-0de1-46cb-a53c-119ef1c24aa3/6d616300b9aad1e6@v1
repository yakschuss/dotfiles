# frozen_string_literal: true

module Chat
  class AccessibleStafferChannel
    include Rails.application.routes.url_helpers

    def self.for_all_members_scoped_to_staffer(account:, staffer:)
      participant = Chat::StafferParticipant.new(staffer)

      channels = SendbirdChatChannel.active.for_account(account).for_sendbird_user(participant.all_sendbird_users)
        .map { |sendbird_chat_channel| new(sendbird_chat_channel: sendbird_chat_channel, sendbird_user: participant.sendbird_user_in_channel(sendbird_chat_channel)) }

      StafferChannelList.new(channels)
    end

    def self.for(account:, member:, staffer:, prefer_unmuted: false)
      channels = SendbirdChatChannel.for(account: account, member: member)
        .where(id: SendbirdChatChannel.for_account(account).for_sendbird_user(staffer.accessible_sendbird_users))
        .tap do |record|
          ActiveRecord::Associations::Preloader.new(
            records: record,
            associations: :_accessible_sendbird_users,
            scope: staffer.accessible_sendbird_users
          ).call
        end
        .flat_map { |sendbird_chat_channel| sendbird_chat_channel._accessible_sendbird_users.map { |sendbird_user| [sendbird_chat_channel, sendbird_user] } }
        .map { |sendbird_chat_channel, sendbird_user| new(sendbird_chat_channel: sendbird_chat_channel, sendbird_user: sendbird_user) }
        .sort_by { |channel| [channel.muted? ? 1 : 0, channel.short_name] }

      if prefer_unmuted
        grouped = channels.group_by(&:sendbird_chat_channel)
        channels = grouped.values.map do |group|
          group.find { |channel| !channel.muted? } || group.first
        end
      end

      StafferChannelList.new(channels)
    end

    # TODO: Something feels off this how from_sendbird_chat_channels_and_staffer queries the data
    def self.from_sendbird_chat_channels_and_staffer(sendbird_chat_channels, staffer)
      participant = Chat::StafferParticipant.new(staffer)
      sendbird_chat_channels.map do |sendbird_chat_channel|
        sendbird_user = participant.sendbird_user_in_channel(sendbird_chat_channel)
        new(sendbird_chat_channel: sendbird_chat_channel, sendbird_user: sendbird_user)
      end
    end

    def self.from_membership(sendbird_chat_channel_membership)
      new(sendbird_chat_channel: sendbird_chat_channel_membership.sendbird_chat_channel,
        sendbird_user: sendbird_chat_channel_membership.sendbird_user)
    end

    attr_reader :sendbird_chat_channel, :sendbird_user
    delegate :deactivated?, :active?, :account, :care_case_id, :last_message_content, :last_message_sent_at, :membership_with_last_sent_message, :nickname_with_last_sent_message, to: :sendbird_chat_channel
    delegate :unread_messages?, :starred?, to: :membership
    delegate :id, to: :membership, prefix: true
    delegate :id, to: :sendbird_user, prefix: true
    delegate :model_name, :to_key, to: :membership

    def initialize(sendbird_chat_channel:, sendbird_user:)
      @sendbird_chat_channel = sendbird_chat_channel
      @sendbird_user = sendbird_user
    end

    # TODO: This shoudn't live here but be specific to the coach chats (conversation?)
    def overdue?
      sendbird_chat_channel.overdue?(sendbird_user)
    end

    def messages?
      sendbird_chat_channel&.membership_with_last_sent_message
    end

    def path
      account_member_chat_path(account, member_participant, sendbird_chat_channel, sendbird_user_id: sendbird_user.id, secondary_tab: parameterized_name)
    end

    def staffer_responded_to_last_message?
      sendbird_chat_channel&.membership_with_last_sent_message&.sendbird_user&.role == Chat::Role.staffer
    end

    def caregiver_chat?
      @is_caregiver_chat ||= member_participant.account_memberships.exists?(account: sendbird_chat_channel.account, relationship: :caregiver)
    end

    def caregiver
      return unless caregiver_chat?

      member_participant
    end

    def child_chat?
      @is_child_chat ||= member_participant.account_memberships.exists?(account: sendbird_chat_channel.account, relationship: :child)
    end

    def child
      return unless child_chat?

      member_participant
    end

    def member_participant
      @member_participant ||= Member.where(id: sendbird_chat_channel
        .sendbird_users
        .where(role: Chat::Role.member)
        .select(:participant_id))
        .first
    end

    def short_name
      Chat::ChannelName.new(sendbird_chat_channel, sendbird_user).short
    end

    def parameterized_name
      short_name.parameterize
    end

    # TODO: Move to Conversation model
    def <=>(other)
      sort_key <=> other.sort_key
    end

    def flagged_as_safety_risk?
      sendbird_chat_channel.flags.any? { |flag| flag.active? && flag.safety_risk? }
    end

    def muted?
      sendbird_user.spectator?
    end

    # Account-level channels (care_case_id nil) are accessible from any care case.
    # Care-case-specific channels are only accessible from their associated care case.
    def accessible_from_care_case?(care_case)
      care_case_id.nil? || care_case_id == care_case.id
    end

    protected

    def sort_key
      [unread_messages? ? 0 : 1, -last_message_sent_at.to_i]
    end

    private

    # TODO: Can we eager load this somehow to prevent an N+1 on the index page???
    def membership
      @membership ||= sendbird_chat_channel.memberships.find_by(sendbird_user: sendbird_user)
    end
  end
end
