# frozen_string_literal: true

module WaitList
  class EntriesController < BaseController
    layout "application_strapless"
    navbar_collapsed

    def index
      authorize WaitList::Entry, policy_class: WaitList::EntryPolicy
      @pagy, @entries = pagy_array(filtered_entries, items: 50)
    end

    def new
      care_case = CareCase.find(params[:care_case_id])
      entry = WaitList::Entry.new(care_case:)

      render turbo_stream: turbo_stream.update(:modal, Staffers::WaitList::EntryModal.new(entry:))
    end

    def edit
      entry = WaitList::Entry.find(params[:id])
      render turbo_stream: turbo_stream.update(:modal, Staffers::WaitList::EntryModal.new(entry:))
    end

    def create
      authorize WaitList::Entry, policy_class: WaitList::EntryPolicy

      care_case = CareCase.find(create_params[:care_case_id])
      root_appointment_type = RootAppointmentType.find(create_params[:root_appointment_type_id])
      unless root_appointment_type.for_clinic?
        # TODO: This is a temporary workaround because non-clinic flows were appointment type based and not
        # root type based. May want to generalize adding "filters" to the be applied to root type.
        appointment_type = root_appointment_type.filtered_appointment_types(communication_assistance: "None").first
      end
      if ::WaitList::Api.join(care_case, reason: ::WaitList::Reason.manual_addition, appointment_type:, root_appointment_type:, **create_params.slice(:added_at, :notes, :clinic_ids, :priority).to_h.symbolize_keys)
        flash[:success] = "Care case added to waitlist"
      else
        flash[:error] = "Failed to add care case to waitlist"
      end

      # use request.referer since the modal is rendered on multiple pages
      redirect_to request.referer, turbo_frame: :_top
    end

    def update
      authorize WaitList::Entry, policy_class: WaitList::EntryPolicy

      entry = WaitList::Entry.find(params[:id])
      entry.update(update_params)

      flash[:success] = "Waitlist entry updated"

      # use request.referer since the modal is rendered on multiple pages
      redirect_to request.referer, turbo_frame: :_top
    end

    helper_method def filter_params
      params.fetch(:filters, {})
        .with_defaults(status: :all_active)
        .permit(:status, :root_appointment_type_id, :priority, :care_case_brightline_id, region_id: [], payer_id: [], clinic_id: []).to_h.symbolize_keys
        .tap { |filters| filters[:priority] = as_boolean(filters[:priority]) }
    end

    helper_method def sort_params
      return {} unless params[:sort].present?

      params.require(:sort).permit(:sort_field, :sort_order, secondary_sort: [:sort_order, :sort_field])
    end

    helper_method def sort_icon(field:)
      icon = if sort_params.blank? || field != sort_params[:sort_field]
        "sort.svg"
      elsif sort_params[:sort_order] == "asc"
        "sort-up.svg"
      else
        "sort-down.svg"
      end

      helpers.inline_svg_tag("icons/streamline/#{icon}", class: "size-3 fill-current")
    end

    private

    def create_params
      params.require(:wait_list_entry).permit(
        :care_case_id,
        :root_appointment_type_id,
        :added_at,
        :notes,
        :priority,
        clinic_ids: []
      ).tap do |permitted_params|
        permitted_params[:clinic_ids] = permitted_params.fetch(:clinic_ids, []).compact_blank
      end
    end

    def update_params
      params.require(:wait_list_entry).permit(
        :root_appointment_type_id,
        :added_at,
        :notes,
        :priority,
        clinic_ids: []
      ).tap do |permitted_params|
        permitted_params[:clinic_ids] = permitted_params.fetch(:clinic_ids, []).compact_blank
      end
    end

    def filtered_entries
      subquery = WaitList::OutreachAttempt
        .select("wait_list_entry_id as id, COUNT(*) AS outreaches")
        .group("wait_list_entry_id").to_sql

      WaitList::Entry
        .filter_by(**filter_params)
        .includes(
          :outreach_attempts,
          care_case: [
            :covered_entities,
            {patient: :caregiver_provided_patient_information},
            {caregivers: :caregiver_provided_patient_information}
          ]
        )
        .joins("LEFT JOIN (#{subquery}) AS outreach_totals ON wait_list_entries.id = outreach_totals.id")
        .select("wait_list_entries.*, coalesce(outreach_totals.outreaches,0) as outreaches")
        .order(sort_order)
    end

    def sort_order
      return {added_at: :asc} unless params[:sort].present?

      sort_field = sort_params[:sort_field]
      sort_order = sort_params[:sort_order]

      {sort_field => sort_order, :added_at => :asc}
    end
  end
end
