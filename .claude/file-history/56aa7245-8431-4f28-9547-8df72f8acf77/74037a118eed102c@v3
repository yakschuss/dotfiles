# frozen_string_literal: true

require "rails_helper"

RSpec.describe SlotRecapture::EligibilityFilter, type: :model do
  describe "#check" do
    def create_intake_appointment(start_time:)
      # therapy_initial_session is an intake type (for_intake: true)
      appointment_type = AppointmentType.therapy_initial_session
      care_case = FactoryBot.create(:care_case)
      FactoryBot.create(:appointment,
        care_case: care_case,
        start_time: start_time,
        end_time: start_time + 1.hour,
        appointment_type_id: appointment_type.id,
        region: care_case.region)
    end

    def create_non_intake_appointment(start_time:)
      # therapy_session_virtual is NOT an intake type (for_intake: false)
      appointment_type = AppointmentType.find("therapy_session_virtual")
      care_case = FactoryBot.create(:care_case)
      FactoryBot.create(:appointment,
        care_case: care_case,
        start_time: start_time,
        end_time: start_time + 1.hour,
        appointment_type_id: appointment_type.id,
        region: care_case.region)
    end

    context "with intake appointments (for_intake: true)" do
      it "returns eligible for intake appointments with sufficient lead time" do
        appointment = create_intake_appointment(start_time: 48.hours.from_now)
        cancelation = FactoryBot.build(:appointment_cancelation, reason: "member_discharged")

        filter = described_class.new
        result = filter.check(appointment: appointment, appointment_cancelation: cancelation)

        expect(result.eligible?).to eq(true)
      end

      it "returns eligible when lead time equals minimum" do
        config = SlotRecapture::ConfigurationData.new(lead_time_hours_minimum: 24)
        # Use 25 hours to account for rounding when converting to integer hours
        appointment = create_intake_appointment(start_time: 25.hours.from_now)
        cancelation = FactoryBot.build(:appointment_cancelation, reason: "member_discharged")

        filter = described_class.new(config: config)
        result = filter.check(appointment: appointment, appointment_cancelation: cancelation)

        expect(result.eligible?).to eq(true)
      end
    end

    context "with non-intake appointments (for_intake: false)" do
      it "returns ineligible for non-intake appointments" do
        appointment = create_non_intake_appointment(start_time: 48.hours.from_now)
        cancelation = FactoryBot.build(:appointment_cancelation, reason: "member_discharged")

        filter = described_class.new
        result = filter.check(appointment: appointment, appointment_cancelation: cancelation)

        expect(result.eligible?).to eq(false)
        expect(result.reason).to include("Not an intake/DE")
      end
    end

    context "with insufficient lead time" do
      it "returns ineligible for appointments with less than minimum lead time" do
        appointment = create_intake_appointment(start_time: 12.hours.from_now)
        cancelation = FactoryBot.build(:appointment_cancelation, reason: "member_discharged")

        filter = described_class.new
        result = filter.check(appointment: appointment, appointment_cancelation: cancelation)

        expect(result.eligible?).to eq(false)
        expect(result.reason).to include("Lead time")
      end
    end

    context "with nil cancelation" do
      it "returns eligible when no cancelation reason provided for intake appointment" do
        appointment = create_intake_appointment(start_time: 48.hours.from_now)

        filter = described_class.new
        result = filter.check(appointment: appointment, appointment_cancelation: nil)

        expect(result.eligible?).to eq(true)
      end
    end

    context "with nil appointment_type" do
      it "returns ineligible gracefully" do
        care_case = FactoryBot.create(:care_case)
        appointment = FactoryBot.build(:appointment,
          care_case: care_case,
          start_time: 48.hours.from_now,
          end_time: 49.hours.from_now,
          appointment_type_id: nil,
          region: care_case.region)

        filter = described_class.new
        result = filter.check(appointment: appointment, appointment_cancelation: nil)

        expect(result.eligible?).to eq(false)
        expect(result.reason).to include("Not an intake/DE")
      end
    end
  end

  describe "Result struct" do
    it "has eligible? method" do
      result = SlotRecapture::EligibilityFilter::Result.new(eligible: true, reason: nil)

      expect(result.eligible?).to eq(true)
    end

    it "has reason attribute" do
      result = SlotRecapture::EligibilityFilter::Result.new(eligible: false, reason: "Some reason")

      expect(result.reason).to eq("Some reason")
    end
  end
end
