# frozen_string_literal: true

# == Schema Information
#
# Table name: slot_recapture_opportunities
#
#  id                       :uuid             not null, primary key
#  lead_time_hours          :integer          not null
#  slot_verified_at         :datetime
#  start_time               :datetime         not null
#  status                   :string           default("pending_verification"), not null
#  created_at               :datetime         not null
#  updated_at               :datetime         not null
#  appointment_type_id      :string           not null
#  cancelled_appointment_id :uuid             not null
#  clinic_id                :uuid             not null
#  region_id                :string           not null
#  root_appointment_type_id :string           not null
#  staffer_id               :uuid             not null
#
# Indexes
#
#  index_slot_recapture_opportunities_on_cancelled_appointment_id  (cancelled_appointment_id) UNIQUE
#  index_slot_recapture_opportunities_on_clinic_id                 (clinic_id)
#  index_slot_recapture_opportunities_on_staffer_id                (staffer_id)
#  index_slot_recapture_opportunities_on_start_time                (start_time)
#  index_slot_recapture_opportunities_on_status                    (status)
#
# Foreign Keys
#
#  fk_rails_...  (cancelled_appointment_id => appointments.id)
#  fk_rails_...  (clinic_id => clinics.id)
#  fk_rails_...  (staffer_id => staffers.id)
#
module SlotRecapture
  class Opportunity < ApplicationRecord
    include StateMachine

    belongs_to :cancelled_appointment, class_name: "Appointment"
    belongs_to :staffer
    belongs_to :clinic
    has_many :outreach_attempts, class_name: "WaitList::OutreachAttempt", foreign_key: :slot_recapture_opportunity_id

    Status = Enum.new(%w[pending_verification open offered filled expired ineligible])

    enum :status, Status.as_string_map, default: Status.pending_verification

    state_machine :status do
      from Status.pending_verification, to: [Status.open, Status.ineligible]
      from Status.open, to: [Status.offered, Status.filled, Status.expired]
      from Status.offered, to: [Status.filled, Status.open, Status.expired]
    end

    scope :actionable, -> { where(status: [Status.open, Status.offered]) }
    scope :pending, -> { where(status: Status.pending_verification) }
    scope :by_start_time, -> { order(:start_time) }

    validates :cancelled_appointment_id, uniqueness: true

    def hours_until_start
      ((start_time - Time.current) / 1.hour).round
    end

    def formatted_time_until_start
      total_hours = hours_until_start
      days = total_hours / 24
      remaining_hours = total_hours % 24
      parts = []
      parts << "#{days} #{"day".pluralize(days)}" if days > 0
      parts << "#{remaining_hours} #{"hour".pluralize(remaining_hours)}" if remaining_hours > 0 || parts.empty?
      parts.join(", ")
    end

    def active_outreach_attempt
      outreach_attempts.active.first
    end

    def appointment_type
      AppointmentType.find(appointment_type_id) if appointment_type_id.present?
    end
  end
end
