# frozen_string_literal: true

module CareCases
  class AvailabilitiesController < BaseController
    include CareCaseScoped
    include ScheduleAppointmentHelpers

    caseload_sidebar

    def show
      @covered_by_california = care_model.brightlife_kids?
      if show_unified_view?
        @form = Calendaring::AvailabilityForm.new(**clinic_availability_filter_params.reverse_merge(care_case_id: current_care_case.id, account_id: current_care_case.account.id))
        @form.track_request
        render :unified_show, layout: "application_strapless"
      elsif show_clinic_view?
        @form = Calendaring::AvailabilityForm.new(**clinic_availability_filter_params.reverse_merge(care_case_id: current_care_case.id, account_id: current_care_case.account.id))
        @form.track_request
        render :clinic_show, layout: "application_strapless"
      else
        @members = CareCaseMember.for(current_care_case, members: care_case_members)
        @members_with_email = CareCaseMember.for(current_care_case, members: care_case_members.with_email)
        @additional_required_capabilities = CareCase::DerivedExtraCapabilities.new(care_case: current_care_case).all
        render :show
      end
    end

    def slots
      @slots = if staffers_for_appointment_type.any?
        Calendaring::AvailableAppointments.new(date_range: date_range, availability_context: availability_context, availability_request_reporter: availability_request_reporter).slots
      else
        {}
      end
    end

    private

    def show_unified_view?
      Flipper.enabled?(:blk_unified_scheduling_view)
    end

    def show_clinic_view?
      care_model.clinic?
    end

    def care_model
      @care_model ||= CareModel.new(care_case: current_care_case)
    end

    def initial_request?
      params[:commit].present?
    end

    def availability_request_reporter
      if initial_request?
        Calendaring::AppointmentAvailabilityRequestReporter.from_availability_context(availability_context)
      else
        Calendaring::NoopAvailabilityRequestReporter.new
      end
    end

    def care_case_members
      current_care_case.members_with_role_names([CaseRoleName.caregiver, CaseRoleName.patient, CaseRoleName.external_caregiver])
    end

    def availability_context
      Calendaring::AvailabilityContext.new(care_case: current_care_case, member: member, appointment_type: appointment_type, staffers: staffers, request_context: Calendaring::AvailabilityRequestContext.member_support_scheduling)
    end

    def staffers
      if filter_params[:staffer_id].present?
        [CareCaseStaffer.new(care_case: current_care_case, staffer: Staffer.find(filter_params[:staffer_id]))]
      else
        CareCaseStaffer.for(current_care_case, staffers: staffers_for_appointment_type)
      end
    end

    helper_method def available_staffers
      return [] unless appointment_type.present?

      @available_staffers ||= [OpenStruct.new(id: nil, full_name_with_roles: "Any Staffer")] + staffers_for_appointment_type
    end

    def staffers_for_appointment_type
      return [] unless appointment_type.present?

      effective_appointment_type = if as_boolean(filter_params[:include_staffers_off_for_intake]) && Calendaring::CapableStaffers::ALTERNATE_APPOINTMENT_MAPPING[appointment_type].present?
        Calendaring::CapableStaffers::ALTERNATE_APPOINTMENT_MAPPING[appointment_type]
      else
        appointment_type
      end

      @staffers_for_appointment_type ||= Calendaring::Api::Availability.capable_staffers(
        root_appointment_type: effective_appointment_type.root_appointment_type,
        filters: {
          appointment_type: effective_appointment_type,
          region: current_care_case.region,
          payer: payer_filter,
          capabilities: additional_required_capabilities,
          limit_to_accepting_new_patients: limit_to_accepting_new_patients?,
          communication_assistance: effective_appointment_type.communication_assistance
        }
      )
    end

    def limit_to_accepting_new_patients?
      # When we're including staffers who are "off for intake",
      # we DON'T want to limit to only those accepting new patients
      !as_boolean(filter_params[:include_staffers_off_for_intake])
    end

    def payer_filter
      # If including uncredentialed staffers, don't filter by payer
      return nil if as_boolean(filter_params[:include_uncredentialed_staffers])

      # Otherwise, filter by the care case's assumed responsible payer
      Eligibility::AssumedResponsiblePayer.for(current_care_case)
    end

    def additional_required_capabilities
      return [] unless appointment_type.coaching?

      if filter_params[:additional_required_capabilities].nil?
        CareCase::DerivedExtraCapabilities.new(care_case: current_care_case).all
      else
        Capability.all.select { |capability| filter_params[:additional_required_capabilities].include?(capability.id.to_s) }
      end
    end

    def member
      @member ||= current_care_case.members.find(filter_params[:member_id])
    end

    helper_method def date_range
      start_date..(start_date + 6.days)
    end

    helper_method def start_date
      @start_date ||= Date.parse(filter_params[:start_date].presence || Time.zone.today.to_s)
    end

    helper_method def selected_time
      return nil unless filter_params[:selected_time]
      @selected_time ||= Time.use_zone(member.timezone) do
        Time.zone.parse(filter_params[:selected_time])
      end
    end

    helper_method def filter_params
      params.permit!.slice(
        :start_date,
        :selected_time,
        :member_id,
        :appointment_type_id,
        :staffer_id,
        :participant_ids,
        :include_uncredentialed_staffers,
        :include_staffers_off_for_intake,
        :additional_required_capabilities
      )
    end

    def clinic_availability_filter_params
      params
        .fetch(:availability_filters, {})
        .permit(
          :clinic_id,
          :payer_id,
          :appointment_type_mode,
          :appointment_duration,
          :root_appointment_type_id,
          :account_id,
          :care_case_id,
          :staffer_id,
          :interpretation_language_id,
          staffer_ids: [],
          clinic_ids: []
        )
        .with_defaults(
          root_appointment_type_id: default_root_appointment_type_id
        )
        .to_h.symbolize_keys
    end

    def default_root_appointment_type_id
      care_model = CareModel.new(care_case: current_care_case)
      RootAppointmentType.for_care_model(care_model.id).first&.id || RootAppointmentType.all.first.id
    end
  end
end
